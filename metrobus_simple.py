"""
Analizador simple de cadenas de Markov para Metrob√∫s CDMX
Versi√≥n de l√≠nea de comandos con an√°lisis b√°sico y visualizaciones
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import json
from typing import List, Dict, Tuple
import warnings
warnings.filterwarnings('ignore')

class MetrobusMarkovSimple:
    """Analizador simplificado para cadenas de Markov del Metrob√∫s"""
    
    def __init__(self, data_folder: str = "data"):
        self.data_folder = Path(data_folder)
        self.stops_df = None
        self.routes_df = None
        self.stop_times_df = None
        self.transition_matrix = None
        self.states = None
        self.state_names = {}
        
        # Configurar matplotlib para espa√±ol
        plt.rcParams['font.size'] = 10
        plt.rcParams['figure.figsize'] = (12, 8)
    
    def cargar_datos(self) -> bool:
        """Carga los datos GTFS del Metrob√∫s"""
        try:
            print("üìÇ Cargando datos del Metrob√∫s...")
            
            # Usar rutas absolutas
            base_path = Path(__file__).parent / self.data_folder
            
            stops_file = base_path / "stops.txt"
            routes_file = base_path / "routes.txt" 
            stop_times_file = base_path / "stop_times.txt"
            
            # Verificar archivos
            for file_path, name in [(stops_file, "stops.txt"), (routes_file, "routes.txt"), 
                                   (stop_times_file, "stop_times.txt")]:
                if not file_path.exists():
                    print(f"‚ùå Archivo no encontrado: {file_path}")
                    print(f"üìÅ Directorio actual: {Path.cwd()}")
                    print(f"üîç Buscando en: {base_path}")
                    return False
            
            self.stops_df = pd.read_csv(stops_file)
            self.routes_df = pd.read_csv(routes_file)
            self.stop_times_df = pd.read_csv(stop_times_file)
            
            print(f"‚úÖ Datos cargados exitosamente:")
            print(f"   üöâ Estaciones: {len(self.stops_df)}")
            print(f"   üöå Rutas: {len(self.routes_df)}")
            print(f"   ‚è∞ Horarios: {len(self.stop_times_df)}")
            
            # Crear mapeo de IDs a nombres
            self.state_names = dict(zip(self.stops_df['stop_id'], self.stops_df['stop_name']))
            
            return True
        except Exception as e:
            print(f"‚ùå Error cargando datos: {e}")
            print(f"üìÅ Directorio actual: {Path.cwd()}")
            print(f"üîç Intentando cargar desde: {self.data_folder}")
            return False
    
    def procesar_secuencias(self, max_trips: int = 200) -> List[List[str]]:
        """Procesa las secuencias de viajes para an√°lisis Markov"""
        print(f"üîÑ Procesando secuencias de viajes (m√°ximo {max_trips})...")
        
        secuencias = []
        trip_ids = self.stop_times_df['trip_id'].unique()[:max_trips]
        
        for trip_id in trip_ids:
            # Obtener paradas del viaje ordenadas por secuencia
            trip_stops = self.stop_times_df[
                self.stop_times_df['trip_id'] == trip_id
            ].sort_values('stop_sequence')
            
            if len(trip_stops) > 1:
                secuencia = trip_stops['stop_id'].tolist()
                secuencias.append(secuencia)
        
        print(f"‚úÖ Se procesaron {len(secuencias)} secuencias v√°lidas")
        return secuencias
    
    def calcular_matriz_transicion(self, secuencias: List[List[str]]) -> np.ndarray:
        """Calcula la matriz de transici√≥n"""
        print("üßÆ Calculando matriz de transici√≥n...")
        
        # Obtener todos los estados √∫nicos
        todos_estados = set()
        for seq in secuencias:
            todos_estados.update(seq)
        
        self.states = sorted(list(todos_estados))
        n_estados = len(self.states)
        
        print(f"üìä Estados √∫nicos encontrados: {n_estados}")
        
        # Crear mapeo estado -> √≠ndice
        estado_a_idx = {estado: i for i, estado in enumerate(self.states)}
        
        # Matriz de conteos
        conteos = np.zeros((n_estados, n_estados))
        
        # Contar transiciones
        total_transiciones = 0
        for seq in secuencias:
            for i in range(len(seq) - 1):
                from_idx = estado_a_idx[seq[i]]
                to_idx = estado_a_idx[seq[i + 1]]
                conteos[from_idx, to_idx] += 1
                total_transiciones += 1
        
        # Normalizar para obtener probabilidades
        sumas_filas = conteos.sum(axis=1)
        sumas_filas[sumas_filas == 0] = 1  # Evitar divisi√≥n por cero
        
        self.transition_matrix = conteos / sumas_filas[:, np.newaxis]
        
        print(f"‚úÖ Matriz calculada: {n_estados}x{n_estados}")
        print(f"üîó Total de transiciones: {total_transiciones}")
        print(f"üìà Densidad de matriz: {(np.count_nonzero(conteos) / (n_estados**2)) * 100:.1f}%")
        
        return self.transition_matrix
    
    def obtener_estadisticas(self) -> Dict:
        """Calcula estad√≠sticas b√°sicas de la matriz"""
        if self.transition_matrix is None:
            return {}
        
        # Conexiones salientes y entrantes
        conexiones_salida = self.transition_matrix.sum(axis=1)
        conexiones_entrada = self.transition_matrix.sum(axis=0)
        
        # Top estaciones
        top_salida_idx = np.argsort(conexiones_salida)[-10:]
        top_entrada_idx = np.argsort(conexiones_entrada)[-10:]
        
        estadisticas = {
            'total_estados': len(self.states),
            'transiciones_activas': np.count_nonzero(self.transition_matrix),
            'densidad': (np.count_nonzero(self.transition_matrix) / len(self.states)**2) * 100,
            'top_salida': [(self.state_names.get(self.states[i], self.states[i]), 
                           conexiones_salida[i]) for i in reversed(top_salida_idx)],
            'top_entrada': [(self.state_names.get(self.states[i], self.states[i]), 
                            conexiones_entrada[i]) for i in reversed(top_entrada_idx)]
        }
        
        return estadisticas
    
    def mostrar_estadisticas(self):
        """Muestra estad√≠sticas en la consola"""
        stats = self.obtener_estadisticas()
        
        print("\n" + "="*60)
        print("üìä ESTAD√çSTICAS DE LA MATRIZ DE TRANSICI√ìN")
        print("="*60)
        
        print(f"üöâ Total de estaciones: {stats['total_estados']}")
        print(f"üîó Transiciones activas: {stats['transiciones_activas']:,}")
        print(f"üìà Densidad de matriz: {stats['densidad']:.1f}%")
        
        print(f"\nüîù TOP 5 ESTACIONES CON M√ÅS CONEXIONES SALIENTES:")
        for i, (nombre, valor) in enumerate(stats['top_salida'][:5], 1):
            print(f"   {i}. {nombre}: {valor:.3f}")
        
        print(f"\nüéØ TOP 5 ESTACIONES CON M√ÅS CONEXIONES ENTRANTES:")
        for i, (nombre, valor) in enumerate(stats['top_entrada'][:5], 1):
            print(f"   {i}. {nombre}: {valor:.3f}")
    
    def visualizar_matriz_calor(self, top_n: int = 15, guardar: bool = True):
        """Crea un mapa de calor de la matriz de transici√≥n"""
        if self.transition_matrix is None:
            print("‚ùå Primero debes calcular la matriz de transici√≥n")
            return
        
        print(f"üé® Creando mapa de calor (top {top_n} estaciones)...")
        
        # Seleccionar las estaciones m√°s activas
        actividad = self.transition_matrix.sum(axis=1) + self.transition_matrix.sum(axis=0)
        top_indices = np.argsort(actividad)[-top_n:]
        
        # Submatriz y nombres
        sub_matriz = self.transition_matrix[np.ix_(top_indices, top_indices)]
        nombres = [self.state_names.get(self.states[i], self.states[i])[:20] 
                  for i in top_indices]
        
        # Crear visualizaci√≥n
        plt.figure(figsize=(14, 10))
        sns.heatmap(sub_matriz, 
                   xticklabels=nombres,
                   yticklabels=nombres,
                   cmap='YlOrRd',
                   annot=False,
                   fmt='.3f',
                   cbar_kws={'label': 'Probabilidad de Transici√≥n'})
        
        plt.title(f'Matriz de Transici√≥n - Top {top_n} Estaciones M√°s Activas\nMetrob√∫s CDMX', 
                 fontsize=16, pad=20)
        plt.xlabel('Estaci√≥n Destino', fontsize=12)
        plt.ylabel('Estaci√≥n Origen', fontsize=12)
        plt.xticks(rotation=45, ha='right')
        plt.yticks(rotation=0)
        plt.tight_layout()
        
        if guardar:
            plt.savefig('matriz_transicion_metrobus.png', dpi=300, bbox_inches='tight')
            print("üíæ Mapa de calor guardado como 'matriz_transicion_metrobus.png'")
        
        plt.show()
    
    def simular_ruta(self, estacion_inicio: str, pasos: int = 10) -> List[str]:
        """Simula una ruta usando la cadena de Markov"""
        if self.transition_matrix is None:
            print("‚ùå Primero debes calcular la matriz de transici√≥n")
            return []
        
        # Buscar la estaci√≥n por nombre
        estacion_id = None
        for stop_id, nombre in self.state_names.items():
            if estacion_inicio.lower() in nombre.lower() and stop_id in self.states:
                estacion_id = stop_id
                break
        
        if estacion_id is None:
            print(f"‚ùå No se encontr√≥ la estaci√≥n '{estacion_inicio}'")
            print("üí° Estaciones disponibles (primeras 10):")
            for i, (stop_id, nombre) in enumerate(list(self.state_names.items())[:10]):
                if stop_id in self.states:
                    print(f"   - {nombre}")
            return []
        
        # Simular
        try:
            idx_actual = self.states.index(estacion_id)
        except ValueError:
            print(f"‚ùå La estaci√≥n no est√° en el modelo")
            return []
        
        simulacion = [estacion_id]
        
        for paso in range(pasos):
            probabilidades = self.transition_matrix[idx_actual]
            
            if probabilidades.sum() == 0:
                print(f"üõë No hay transiciones posibles desde {self.state_names[estacion_id]}")
                break
            
            siguiente_idx = np.random.choice(len(self.states), p=probabilidades)
            siguiente_id = self.states[siguiente_idx]
            simulacion.append(siguiente_id)
            idx_actual = siguiente_idx
        
        return simulacion
    
    def mostrar_ruta_simulada(self, estacion_inicio: str, pasos: int = 10):
        """Muestra una ruta simulada de forma bonita"""
        print(f"\nüöÄ Simulando ruta desde '{estacion_inicio}' ({pasos} pasos)...")
        
        ruta = self.simular_ruta(estacion_inicio, pasos)
        
        if not ruta:
            return
        
        print(f"\nüõ§Ô∏è  RUTA SIMULADA:")
        print("="*50)
        
        for i, stop_id in enumerate(ruta):
            nombre = self.state_names.get(stop_id, stop_id)
            if i == 0:
                print(f"üöè INICIO: {nombre}")
            elif i == len(ruta) - 1:
                print(f"üèÅ FIN:    {nombre}")
            else:
                print(f"   {i:2d}:    {nombre}")
        
        print(f"\nüìç Total de paradas: {len(ruta)}")
    
    def analisis_completo(self, max_trips: int = 200, top_n: int = 15):
        """Ejecuta un an√°lisis completo del sistema"""
        print("üöå AN√ÅLISIS COMPLETO DEL METROB√öS CDMX")
        print("="*60)
        
        # 1. Cargar datos
        if not self.cargar_datos():
            return False
        
        # 2. Procesar secuencias
        secuencias = self.procesar_secuencias(max_trips)
        if not secuencias:
            print("‚ùå No se pudieron procesar las secuencias")
            return False
        
        # 3. Calcular matriz
        self.calcular_matriz_transicion(secuencias)
        
        # 4. Mostrar estad√≠sticas
        self.mostrar_estadisticas()
        
        # 5. Crear visualizaci√≥n
        self.visualizar_matriz_calor(top_n)
        
        # 6. Ejemplo de simulaci√≥n
        print(f"\nüéØ EJEMPLO DE SIMULACI√ìN:")
        self.mostrar_ruta_simulada("Buenavista", 8)
        
        print(f"\n‚úÖ An√°lisis completo finalizado!")
        print(f"üí° Puedes usar los m√©todos individuales para an√°lisis espec√≠ficos")
        
        return True


def main():
    """Funci√≥n principal de demostraci√≥n"""
    # Crear analizador
    analizador = MetrobusMarkovSimple()
    
    # Ejecutar an√°lisis completo
    exito = analizador.analisis_completo(max_trips=300, top_n=12)
    
    if exito:
        print(f"\nüéâ ¬°An√°lisis completado exitosamente!")
        print(f"üìä Revisa la imagen 'matriz_transicion_metrobus.png'")
        print(f"üîÑ Puedes hacer m√°s simulaciones con:")
        print(f"   analizador.mostrar_ruta_simulada('NombreEstacion', pasos)")


if __name__ == "__main__":
    main()
